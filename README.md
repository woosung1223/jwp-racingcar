# jwp-racingcar

# 페어 프로그래밍 룰

## 스위치 기준

- [x] 스위치 시간은 20분으로 한다.
- [x] 내비게이터는 전자기기에 손을 대지 않는다.

## 깃 컨벤션

- [x] 기능 목록에 있는 기능 단위로 커밋한다.
- [x] 작동할 수 있는 기능 단위로 커밋한다.
- [x] 커밋 메세지는 아래 키워드를 사용해 기능 목록 그대로 작성한다.
    - feat: 기능 구현을 완료했을 때
    - refactor: 기능의 변화 없이 코드를 변경했을 때
    - test: 테스트 코드만 작성했을 때
    - chore: 패키지 변경 등 사소한 수정사항이 생겼을 때
    - fix: 프로그램의 결함을 수정할 때
    - docs: 문서를 수정할 때

## 코드 컨벤션

- [x] 모든 클래스는 `final` 혹은 `abstract` 이어야 한다.
- [x] 모든 파라미터에 `final` 키워드를 붙인다.

## 구현 계획

- [x] 구현은 다음과 같은 순서로 진행된다.
    1. Spring MVC 학습
    2. 자동차 경주 미션 - 웹 요청/응답 구현하기
    3. Spring JDBC 학습
    4. 자동차 경주 미션 - DB 연동하기
    5. 리팩토링

## 기타 룰

- [x] 미션 진행 2일차(수) 오후 4:00에 중간 회고를 진행한다.
- [x] 최소한 2시간에 한 번은 쉬어야 한다.
- [x] 커피챗을 최소 1회 진행한다.
- [x] 집중이 안된다면 페어에게 솔직하게 이야기한다.

---

# 추가로 구현할 기능 목록

## 웹 애플리케이션 구동

- [x] 자동차 경주 진행에 대한 웹 API를 구현한다.
    - [x] 자동차 경주 진행에 대한 웹 요청을 받을 수 있다.
        - [x] JSON 형태로 입력을 받는다.
            - [x] 참여자들의 이름을 입력받는다.
            - [x] 시도 횟수를 입력받는다.
        - [x] `/plays`로 `POST` 요청을 보낼 시 응답한다.
    - [x] 자동차 경주 진행 결과에 대한 웹 응답을 전달할 수 있다.
        - [x] JSON 형태로 전달한다.
            - [x] 우승자들의 이름을 전달한다.
            - [x] 참여자들의 정보를 전달한다.
                - [x] 모든 참여자들의 이름을 전달한다.
                - [x] 모든 참여자들의 이동 거리를 전달한다.
                - [x] 이동 거리의 내림차순으로 정렬 후 전달한다.
        - [x] 성공 시 STATUS CODE `200`를 반환한다.
        - [x] 실패 시 다음과 같은 STATUS CODE를 반환한다.
            - [x] 사용자 입력이 잘못되었을 때는 `400`을 반환한다.
            - [x] 정의되지 않은 경로로 요청하는 경우 `404`를 반환한다.
            - [x] 정의되지 않은 HTTP 메서드를 호출했을 때는 `405`를 반환한다.
            - [x] 서버 내부에서 에러가 발생했을 때는 `500`을 반환한다.
    - [x] 플레이 이력 조회에 대한 웹 요청을 받을 수 있다.
        - [x] `/plays`로 `GET` 요청을 보낼 시 응답한다.
    - [x] 플레이 이력 조회에 대한 웹 응답을 전달할 수 있다.
        - [x] JSON 형태로 전달한다.
            - [x] 우승자들의 이름을 전달한다.
            - [x] 참여자들의 정보를 전달한다.

## DB 연동

- [x] 자동차 경주 게임 플레이 이력을 DB에 저장한다.
    - [x] H2 Database에 저장된다.
    - [x] 저장되는 정보는 다음과 같다.
        - [x] 플레이 횟수
        - [x] 플레이어 별 최종 이동 거리(이름, 최종 위치)
        - [x] 우승자
        - [x] 플레이한 날짜/시간

# TO-STUDY

- [ ] `@Transactional` 학습, 어떻게 사용할 수 있는지
- [ ] Mock 테스트의 테스트 범위와 원리 학습하기
- [ ] RequestBody + Model 같이 사용할 수 있는지
- [ ] RequestBody의 required가 어떻게 동작하는지

# 고민사항

- [ ] 이너클래스로 `CarDTO`를 둘지, 외부 객체로 뺼지
- [ ] 어느 기준으로 DTO를 생성해야 할지
    - [ ] Controller - Service, Service - Dao 사이마다 DTO를 새로 정의해야 하는지(필드가 새롭게 추가되는 경우)
- [ ] DAO를 하나의 테이블씩 매핑시키고, 이를 Repository에서 Join하려고 했으나 SELECT문으로 받기 위한 정보들을 또 VO로 객체를 만들어야 할까?
    - [ ] 테이블과 매핑이 되는 객체가 필요한 이 시점에서 Entity라는 객체가 필요하게 되는 것일까?
- [ ] 도메인 객체의 의존성 주입은 누가 하는게 옳을까?
    - [ ] 예를 들어, `RandomNumberGenerator`는 누가 주입 책임을 갖는게 맞을까?
- [ ] Repository에서 Entity 정보를 토대로 도메인 객체를 조합할 때, 이전 도메인 구조에서는 조합이 불가능하다는 것을 꺠달음
    - [ ] `Car` 객체의 `Position`을 조합해 `RacingGame` 객체를 만들 수 없음
        - [ ] 따라서, **웹 어플리케이션에 맞는** 도메인 구조를 만드는 것이 중요해 보임
        - [ ] 어떻게 해야 할까?

---

# 리팩토링 기록

- [x] 컨트롤러 `RestController`로 변경
- [x] 클라이언트에게 `ResponseEntity`로 응답하도록 변경
    - [x] 보다 상세한 응답 코드, 헤더 등을 전달할 수 있음
- [x] DTO 클래스명이 `DTO`라는 키워드를 내포하지 않도록 변경
    - [x] 명확하게 비즈니스적인 표현이 가능해짐
- [x] 빈 객체의 테스트에서 생성 책임을 컨테이너에게 위임
    - [x] 생성 책임을 위임함에 따라 주입할 더미 객체를 만들 필요가 사라짐
- [x] `@JDBCTest`를 사용해 table을 삭제, 생성하는 과정을 명시하지 않도록 변경
    - [x] `@JDBCTest`는 내부적으로 `Transactional`함
    - [x] 기본적으로 테스트 메소드마다 `Rollback`을 수행함
        - [x] 따라서 `CREATE TABLE`, `DROP TABLE` 과정을 수동으로 할 필요가 없음
- [x] `RestControllerAdvice`, `ExceptionHandler`를 이용한 전역 예외처리
    - [x] `RestController`의 경우 `RestControllerAdvice`를 사용해야 함
        - [x] 두 어노테이션의 차이는 `RestController`와 `Controller`의 차이와 같음
    - [x] `ExceptionResponse` DTO 사용을 통한 예외 메세지 구조화
- [ ] DAO가 하나의 테이블에 매핑되도록 변경
    - [ ] 직관적이라 좋은데, 이것이 좋은 구조인지는 고민해봐야 할 듯
- [ ] 콘솔 어플리케이션이 웹 Service, Repository 를 재사용하도록 변경
- [ ] ControllerAdvice를 역할에 따라 추가 분리
    - [ ] 예외도 성격이 존재하기 때문에(도메인이거나, 아니거나 등) 이에 따라 분리하자는 취지
    - [ ] `@Order` 어노테이션을 사용해 우선순위를 조정했는데, 보다 좋은 방법이 있을까? 추가 고민해보기
    - [ ] https://velog.io/@xodud001/%ED%98%B8%EC%B6%9C%EB%90%A0-%EA%B1%B0%EB%9D%BC-%EC%98%88%EC%83%81%ED%96%88%EB%8D%98-ExceptionHandler%EA%B0%80-%EC%9D%BC%EC%9D%84-%EC%95%88-%ED%95%98%EB%84%A4
    - [ ] 알고보니 스프링에서는 가장 구체적인 예외 핸들러를 사용함. 위 정보는 거짓.
- [ ] `@Transactional` 어노테이션 사용
    - [ ] 여러 테이블에 접근하는 로직이 있으므로 원자성을 보장해야 함
- [ ] 계층 간 전달되는 데이터 형식을 고정시킴
    - [ ] Repository - DAO -> Entity
    - [ ] Service - Repository -> Domain
    - [ ] Controller - Service -> Domain
    - [ ] Client - Controller -> DTO
    - [ ] 이 과정을 통해 Layered Architecture를 따를 수 있었음
- [ ] 계층 간 `Converter` 객체를 둘지에 대한 고민을 해봐야겠음
- [ ] Mock을 통한 테스트 개선
    - [ ] 추후 따로 학습이 필요함
- [ ] Service에서 DTO가 아닌 도메인 객체를 반환하도록 수정
    - [ ] 재사용성이 증가됨
    - [ ] 특정한 문맥(DTO)에만 고정되지 않을 수 있음
- [ ] 예외처리 시 Logger 사용
    - [ ] `sout`과 다르게 환경에 구속되지 않는다(파일 등에도 적용가능)
    - [ ] 멀티스레딩 환경에서도 더 좋은 성능을 낼 수 있다
    - [ ] 스레드 정보 등 더 많은 정보를 로그에 남기고 싶은 경우 사용할 수 있음
- [ ] 엔티티에서 필드를 모두 Wrapper 타입으로 변경
    - [ ] 원시타입을 사용하면 null을 표현할 수 없음
